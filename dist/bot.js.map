{"version":3,"sources":["bot.js"],"names":["github","bot","polling","onText","search","regex","msg","matches","searchData","scope","term","scopeKeys","Object","keys","scopes","find","item","keywords","includes","sendMessage","chat","id","options","defaultOptions","q","result","parse_mode","on","text","query","commandNames","knownCommand","exec","initMessage","command","inlineRegex","answerInlineQuery","type","title","description","message_text","switch_pm_text","switch_pm_parameter","response"],"mappings":"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","file":"bot.js","sourcesContent":["import TelegramBot from 'node-telegram-bot-api'; \nimport * as github from './github'; import {token} \nfrom './config'; import {loadTemplate, \nloadInlineTemplate} from './templates'; import \ncommands from './commands'; const bot = new \nTelegramBot(token, {polling: true}); \nbot.onText(commands.search.regex, async(msg, \nmatches) => {\n    const searchData = {\n        scope: matches[1],\n        term: matches[2]\n    };\n    const scopeKeys = Object.keys(github.scopes);\n    const scope = scopeKeys.find(item => {\n        return github\n            .scopes[item]\n            .keywords\n            .includes(searchData.scope)\n    });\n    if (!scope) {\n        return bot.sendMessage(msg.chat.id, `I don't \nunderstand what's that \"${searchData.scope}\"!`)\n    }\n    const options = {\n        ...github.scopes[scope].defaultOptions,\n        q: searchData.term\n    };\n    const result = await github.search(scope, \noptions);\n    bot.sendMessage(msg.chat.id, loadTemplate(scope, \nresult), {parse_mode: 'Markdown'})\n});\nbot.on('message', msg => {\n    if (!msg.text && !msg.query) {\n        return bot.sendMessage(msg.chat.id, `Sry! I \nonly understand text stuff. Use /help to get some \nhelp about my commands.`)\n    }\n    const commandNames = Object.keys(commands);\n    const knownCommand = commandNames.find(item => {\n        return commands[item]\n            .regex\n            .exec(msg.text)\n    });\n    if (knownCommand && \ncommands[knownCommand].initMessage) {\n        return bot.sendMessage(msg.chat.id, \ncommands[knownCommand].initMessage, {parse_mode: \n'Markdown'})\n    }\n    if (knownCommand || msg.query) {\n        return false\n    }\n    bot.sendMessage(msg.chat.id, `Sry! I didn't \nunderstand that \"${msg.text}\". Use /help to get some \nhelp about my commands.`)\n});\nbot.on('inline_query', async msg => {\n    const commandNames = Object.keys(commands);\n    const command = commandNames.find(item => {\n        return commands[item].inlineRegex && \ncommands[item]\n            .inlineRegex\n            .exec(msg.query)\n    });\n    if (command !== 'search') {\n        return bot.answerInlineQuery(msg.id, [\n            {\n                id: '1',\n                type: 'article',\n                title: 'Not found',\n                description: 'Command not found!',\n                message_text: 'Command not found!',\n                switch_pm_text: 'Help',\n                switch_pm_parameter: 'inline-help'}\n    ]);\n  }\n    const matches = commands[command]\n        .inlineRegex\n        .exec(msg.query);\n    const searchData = {\n        scope: matches[1],\n        term: matches[2]\n    };\n    const scopeKeys = Object.keys(github.scopes);\n    const scope = scopeKeys.find(item => {\n        return github\n            .scopes[item]\n            .keywords\n            .includes(searchData.scope)\n    });\n    if (!scope) {\n        return bot.answerInlineQuery(msg.id, [\n            {\n                id: '1',\n                type: 'article',\n                title: 'Invalid Scope',\n                description: `I don't understand \nwhat's that \"${searchData.scope}\"!`,\n                message_text: `I don't understand \nwhat's that \"${searchData.scope}\"!`\n            }\n        ])\n    }\n    const options = {\n        ...github.scopes[scope].defaultOptions,\n        q: searchData.term\n    };\n    const response = await github.search(scope, \noptions);\n    bot.answerInlineQuery(msg.id, \nloadInlineTemplate(scope, response))\n});\nexport default bot;\n"]}