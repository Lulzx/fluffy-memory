{"version":3,"sources":["bot.js"],"names":["github","bot","polling","onText","search","regex","msg","matches","searchData","scope","term","scopeKeys","Object","keys","scopes","find","item","keywords","includes","sendMessage","chat","id","options","defaultOptions","q","result","parse_mode","on","text","query","commandNames","knownCommand","exec","initMessage","command","inlineRegex","answerInlineQuery","type","title","description","message_text","switch_pm_text","switch_pm_parameter","response"],"mappings":"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","file":"bot.js","sourcesContent":["import TelegramBot from 'node-telegram-bot-api';\nimport * as github from './github';\nimport {token} from './config';\nimport {loadTemplate, loadInlineTemplate} from './templates';\nimport commands from './commands';\nconst bot = new TelegramBot(token, {polling: true});\nbot.onText(commands.search.regex, async(msg, matches) => {\n    const searchData = {\n        scope: matches[1],\n        term: matches[2]\n    };\n    const scopeKeys = Object.keys(github.scopes);\n    const scope = scopeKeys.find(item => {\n        return github\n            .scopes[item]\n            .keywords\n            .includes(searchData.scope)\n    });\n    if (!scope) {\n        return bot.sendMessage(msg.chat.id, `I don't understand what's that \"${searchData.scope}\"!`)\n    }\n    const options = {\n        ...github.scopes[scope].defaultOptions,\n        q: searchData.term\n    };\n    const result = await github.search(scope, options);\n    bot.sendMessage(msg.chat.id, loadTemplate(scope, result), {parse_mode: 'Markdown'})\n});\nbot.on('message', msg => {\n    if (!msg.text && !msg.query) {\n        return bot.sendMessage(msg.chat.id, `Sry! I only understand text stuff.\nUse /help to get some help about my commands.`)\n    }\n    const commandNames = Object.keys(commands);\n    const knownCommand = commandNames.find(item => {\n        return commands[item]\n            .regex\n            .exec(msg.text)\n    });\n    if (knownCommand && commands[knownCommand].initMessage) {\n        return bot.sendMessage(msg.chat.id, commands[knownCommand].initMessage, {parse_mode: 'Markdown'})\n    }\n    if (knownCommand || msg.query) {\n        return false\n    }\n    bot.sendMessage(msg.chat.id, `Sry! I didn't understand that \"${msg.text}\".\nUse /help to get some help about my commands.`)\n});\nbot.on('inline_query', async msg => {\n    const commandNames = Object.keys(commands);\n    const command = commandNames.find(item => {\n        return commands[item].inlineRegex && commands[item]\n            .inlineRegex\n            .exec(msg.query)\n    });\n    if (command !== 'search') {\n        return bot.answerInlineQuery(msg.id, [\n            {\n                id: '1',\n                type: 'article',\n                title: 'Not found',\n                description: 'Command not found!',\n                message_text: 'Command not found!'\n            }\n        ], switch_pm_text = 'Help', switch_pm_parameter = 'inline-help')\n    }\n    const matches = commands[command]\n        .inlineRegex\n        .exec(msg.query);\n    const searchData = {\n        scope: matches[1],\n        term: matches[2]\n    };\n    const scopeKeys = Object.keys(github.scopes);\n    const scope = scopeKeys.find(item => {\n        return github\n            .scopes[item]\n            .keywords\n            .includes(searchData.scope)\n    });\n    if (!scope) {\n        return bot.answerInlineQuery(msg.id, [\n            {\n                id: '1',\n                type: 'article',\n                title: 'Invalid Scope',\n                description: `I don't understand what's that \"${searchData.scope}\"!`,\n                message_text: `I don't understand what's that \"${searchData.scope}\"!`\n            }\n        ])\n    }\n    const options = {\n        ...github.scopes[scope].defaultOptions,\n        q: searchData.term\n    };\n    const response = await github.search(scope, options);\n    bot.answerInlineQuery(msg.id, loadInlineTemplate(scope, response))\n});\nexport default bot;\n"]}